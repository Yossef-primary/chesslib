package chesslib;

import chesslib.move.Move;
import chesslib.types.*;

import java.util.*;

import static chesslib.Bitboard.*;
import static chesslib.move.Move.*;
import static chesslib.types.Castling.*;
import static chesslib.types.Direction.forward;
import static chesslib.types.File.*;
import static chesslib.types.Rank.*;
import static chesslib.types.Side.*;
import static chesslib.types.PieceType.*;
import static chesslib.types.Piece.*;
import static chesslib.types.Square.*;

/**
 * Represents a chess position and provides methods for manipulating the position state.
 * The class utilizes bitboards and arrays for an efficient board representation.
 * Key components include tracking the current state, managing the board, handling castling options,
 * and using Zobrist hashing for position keys.
 * The class supports Chess960 (Fischer Random Chess) rules and includes methods for making and undoing moves,
 * checking legality, generating FEN strings, setting positions from FEN strings, and more.
 */
public class Position {
    // Constants defining the conditions for a draw
    private static final int NUM_REPETITION_TO_DRAW = 3;
    private static final int RULE_50_COUNT_TO_DRAW = 100; // i think the correct number is 100 not 99


    /**
     * Represents the current state valueOf the chess position.
     */
    private int sideToMove;           // The side currently making a move (WHITE or BLACK)
    private int numMoves;             // Total number valueOf moves made in the game
    private PositionState state;      // Detailed state valueOf the current position, including king info, castling rights, etc.


// Board representation using bitboards and arrays

    // `occupancyBB` is a bitboard representing occupied squares on the board.
    private long occupancyBB;
    // `occupancyBySideBB` holds bitboards for each side separately (WHITE and BLACK).
    private long[] occupancyBySideBB;

    // `occupancyByPieceBB` represents bitboards for each piece.
    private long[] occupancyByPieceBB;

    // `occupancyByTypeBB` is an array valueOf bitboards, one for each piece type.
    private long[] occupancyByTypeBB;

    // `board` is an array representing the piece on each square.
    private int[] board;

    // `isChess960` is a flag indicating whether Chess960 rules are in effect.
    private boolean isChess960;


    // `numPieces` counts the total number valueOf pieces on the board.
    private int numPieces;


// Castling-related data

    // `castlingOptionsMask` represents available castling options for each square.
    private int[] castlingOptionsMask;

    private int[] castlingDestSquareKing;

    private int[] castlingDestSquareRook;
    // `castlingMoves` is an array containing encoded castling moves.
    private int[] castlingMoves;

    // all the squares that king and rook go through while performing castling. Excludes the king square
    // and rook square. This path must be empty on the board when making the castling move.
    private long[] castlingPath;

    // all the squares the king goes through while performing castling. Excludes the king square.
    // This path cannot be under attack by enemy pieces.
    private long[] castlingKingPath;


// Keys tables for position hashing
    // `pieceSquareKeys` holds random keys for each piece on each square.
    private static final long[][] pieceSquareKeys = new long[Piece.VALUES_COUNT][Square.VALUES_COUNT];
    // `enPassantKeys` holds random keys for en passant squares.
    private static final long[] enPassantKeys = new long[Square.VALUES_COUNT];
    // `castlingKeys` holds random keys for each castling option.
    private static final long[] castlingKeys = new long[Castling.SIZE];
    // `colorKey` holds a random key for the side to move.
    private static final long colorKey;

    // Static block to initialize key tables
    // Random keys are generated for each table.
    static {
        Random r = SharedRandom.RANDOM;
        // Initialize keys for pieces on each square
        for (int piece : Piece.intValues())
            for (int square = A1_VAL; square <= H8_VAL; ++square)
                pieceSquareKeys[piece][square] = r.nextLong();

        // Initialize keys for castling options
        for (int i = 0; i < castlingKeys.length; ++i)
            castlingKeys[i] = r.nextLong();

        // Initialize keys for en passant squares
        for (int square = A1_VAL; square <= H8_VAL; ++square) {
            enPassantKeys[square] = r.nextLong();
            enPassantKeys[Square.flipped(square)] = r.nextLong();
        }
        // Special case for no en passant square
        enPassantKeys[NO_SQUARE_VAL] = 0;

        // Initialize a random key for the side to move
        colorKey = r.nextLong();
    }

    // TODO: 07/03/2025 try to limit the sending the PositionState as argument.
    /**
     * Creates a new chess position based on the provided FEN string, state, and Chess960 flag.
     *
     * @param newFen     The FEN string representing the initial position valueOf the chessboard.
     * @param isChess960 A flag indicating whether Chess960 rules are in effect.
     */
    public Position(String newFen, boolean isChess960) {
        // Initialize the position using the provided FEN string, state, and Chess960 flag
        setFen(newFen, isChess960);
    }


    /**
     * Prints the current chess position board representation along with additional information.
     */
    public void printBoard(){
        System.out.println(posString());
    }

    /**
     * Sets the position state based on the given FEN (Forsyth–Edwards Notation) string, along with additional
     * information about castling, en passant, rule50, and full move count. Assumes the provided FEN is valid.
     * <p>
     * FEN Format:
     * 1. Board state: The arrangement valueOf pieces on the chessboard. Each rank is represented by a string valueOf characters.
     * Pieces are represented by their initials, and empty squares by a number representing the count valueOf consecutive empty squares.
     * <p>
     * 2. Color to move: 'w' for white, 'b' for black.
     * <p>
     * 3. Castling rights: A combination valueOf 'K', 'Q', 'k', 'q' to indicate whether castling is allowed for each side.
     * 'K' and 'k' represent king side castling, while 'Q' and 'q' represent queen side castling. If castling is not
     * allowed for a side, it is represented by '-'.
     * <p>
     * 4. En passant square: The square where an en passant capture is possible. Represented by the square's name,
     * e.g., 'e3'. If there is no en passant square, it is represented by '-'.
     * <p>
     * 5. Rule50: The half-move clock, indicating the number valueOf half-moves since the last capture or pawn move.
     * <p>
     * 6. Full move count: The number valueOf the full move. It starts at 1 and is incremented after each move by black.
     * <p>
     * Note: This method assumes the provided FEN is valid and performs the necessary updates to the internal state
     * and position count table. It initializes the board, castling options, en passant, and other related data
     * structures based on the parsed FEN information.
     *
     * @param fen           The FEN string representing the chess position.
     * @param isChess960Mod Flag indicating whether Chess960 (Fischer Random Chess) rules are applied.
     */
    public void setFen(String fen, boolean isChess960Mod) {
        assert FenValidation.isValidFen(fen);
//        assert FenValidation.isValidFen(fen);
//        if (!FenValidation.isValidFen(fen)){
//            System.out.println("999((((((((((((((((((((((((((((((((((((((((((((((((((((((((");
//        }

        // 0. pars fen
        String[] fenParts = splitFen(fen);
        String boardFen = fenParts[0], colorFen =  fenParts[1], castlingFen =      fenParts[2],
                epFen =    fenParts[3], rule50Fen = fenParts[4], fullMoveCountFen = fenParts[5];

        // 0. init class main data
        isChess960 = isChess960Mod;
        state      = new PositionState();
        sideToMove = Side.valueOf(colorFen.charAt(0));
        numMoves   = 2 * (Integer.parseInt(fullMoveCountFen) -1) + sideToMove; // num moves start from 0

        // 1. reset the board
        occupancyBB = 0;
        occupancyBySideBB      = new long[Side.VALUES_COUNT];
        occupancyByPieceBB     = new long[Piece.VALUES_COUNT];
        occupancyByTypeBB      = new long[PieceType.VALUES_COUNT];
        board                  = new int[Square.VALUES_COUNT];

        castlingOptionsMask    = new int[Square.VALUES_COUNT];
        castlingDestSquareKing = new int[Square.VALUES_COUNT];
        castlingDestSquareRook = new int[Square.VALUES_COUNT];
        castlingPath           = new long[Square.VALUES_COUNT];
        castlingKingPath       = new long[Square.VALUES_COUNT];
        castlingMoves          = new int[Castling.SIZE];

        // 2. set the board
        int square = A8_VAL;
        for (char c : boardFen.toCharArray()) {
            if (c == '/')
                square = square - 2*Rank.SIZE; // go down in a rank
            else if (Character.isDigit(c))
                square += Character.getNumericValue(c);
            else // add piece and advance square
                addPiece(Piece.valueOf(c), square++);
        }

        int[] kingsSquares = {squareOf(WHITE_KING_VAL), squareOf(BLACK_KING_VAL)};

        // 3. set castling info
        int castlingRights = 0;
        Arrays.fill(castlingOptionsMask, ALL_CASTLING);

        castlingOptionsMask[kingsSquares[WHITE_VAL]] = ALL_CASTLING - (WHITE_SHORT | WHITE_LONG);
        castlingOptionsMask[kingsSquares[BLACK_VAL]] = ALL_CASTLING - (BLACK_SHORT | BLACK_LONG);

        for (char c : castlingFen.toCharArray()) {
            int side = Character.isUpperCase(c) ? WHITE_VAL : BLACK_VAL;
            c = Character.toLowerCase(c);
            int rookSq, kingSq = kingsSquares[side];

            // find the rookSq square, that made the castle.
            if (c == 'k') {
                rookSq = Square.flippedIfBlack(side, H1_VAL);
                while (getPiece(rookSq) != Piece.valueOf(side, ROOK_VAL) && rookSq > A1_VAL) rookSq--;

            }
            else if (c == 'q'){
                rookSq = Square.flippedIfBlack(side, A1_VAL);
                while (getPiece(rookSq) != Piece.valueOf(side, ROOK_VAL) && rookSq < H1_VAL) rookSq++;
            }

            else if (c >= 'a' && c <= 'h')
                rookSq = Square.value(File.of(c), Rank.flippedIfBlack(side, Rank.RANK_1_VAL));
            else break; // c = "-"

            int castleRight = rookSq > kingSq ? shortCastle(side) : longCastle(side);
            assert positionIsLegal() == isCastlingAvailableOnPosition(castleRight, kingSq, rookSq);
            if (isCastlingAvailableOnPosition(castleRight, kingSq, rookSq)) { // todo make shure that check not make bug
                int destKing = isShortCastle(castleRight) ? Square.flippedIfBlack(side, G1_VAL) : Square.flippedIfBlack(side, C1_VAL);
                int destRook = isShortCastle(castleRight) ? Square.flippedIfBlack(side, F1_VAL) : Square.flippedIfBlack(side, D1_VAL);

                isCastlingAvailableOnPosition(castleRight, kingSq, rookSq);
                //update castle right info
                castlingRights += castleRight;
                castlingOptionsMask[rookSq] = ALL_CASTLING - castleRight;
                castlingDestSquareKing[rookSq] = destKing;
                castlingDestSquareRook[rookSq] = destRook;
                castlingKingPath[rookSq] = pathBetween(kingSq, destKing) & ~squareToBB(kingSq);
                castlingPath[rookSq] = castlingKingPath[rookSq] | pathBetween(rookSq, destRook) & ~squareToBB(rookSq);
                castlingMoves[castleRight] = createMove(kingSq, rookSq, CASTLING);
            }
        }

        // 4. set epPassant sq.
        int enSq = "-".equals(epFen) ? NO_SQUARE_VAL : Square.value(epFen);
        int sideMoved = Side.flipped(sideToMove);
        int pawnMovedDir = forward(sideMoved);
        // if on valueOf this condition exist en passant move cant be done.
        if (enSq == NO_SQUARE_VAL                                                                     ||
                // check if exist pawn after the ep square.
                (occupancyBySideAndType(sideMoved, PAWN_VAL) & squareToBB(enSq + pawnMovedDir)) == 0  ||
                // check it the squares that pawn moved goes through them are empty.
                ((squareToBB(enSq - pawnMovedDir) | squareToBB(enSq)) & occupancyBB) != 0             ||
                // check if exist pawn valueOf side to move that can go to ep square.
                (occupancyBySideAndType(sideToMove, PAWN_VAL) & pawnAttacks(sideMoved, enSq)) == 0)
            enSq = NO_SQUARE_VAL;

        // 5. set state
        state.enPassant          = enSq;
        state.rule50             = Integer.parseInt(rule50Fen);
        state.kingSquare         = kingsSquares[sideToMove];
        state.capturedPiece      = NO_PIECE_VAL;
        state.numRepetition      = 0;
        state.ply                = 0;
        state.previous           = null;
        state.castlingRights     = castlingRights;
        state.checkers           = attackersBB(Side.flipped(sideToMove), state.kingSquare, occupancyBB);
        state.pinMask            = pinMask(Side.flipped(sideToMove), state.kingSquare);
        state.pinMask2[sideToMove]= pinMask(sideMoved, state.kingSquare);
        state.pinMask2[sideMoved]= pinMask(sideToMove, squareOf(sideMoved, KING_VAL));
        state.key                = (sideToMove*colorKey) ^ enPassantKeys[state.enPassant] ^ castlingKeys[castlingRights];
        state.lastMove           = NULL_MOVE;
//        assertPositionIsLegal();

        if (checker() != 0 && enPassant() != NO_SQUARE_VAL){

        }

    }



    int setCastlingRights(String castlingFen){
        int castlingRights = 0;
        Arrays.fill(castlingOptionsMask, ALL_CASTLING);
        int wKing = squareOf(WHITE_VAL, KING_VAL);
        int bKing = squareOf(BLACK_VAL, KING_VAL);

        castlingOptionsMask[wKing] = ALL_CASTLING - (WHITE_SHORT | WHITE_LONG);
        castlingOptionsMask[bKing] = ALL_CASTLING - (BLACK_SHORT | BLACK_LONG);

        int[] kingsSquares = {wKing, bKing};

        for (char c : castlingFen.toCharArray()) {
            int side = Character.isUpperCase(c) ? WHITE_VAL : BLACK_VAL;
            c = Character.toLowerCase(c);
            int rookSq, kingSq = kingsSquares[side];

            // find the rookSq square, that made the castle.
            if (c == 'k') {
                rookSq = Square.flippedIfBlack(side, H1_VAL);
                while (getPiece(rookSq) != Piece.valueOf(side, ROOK_VAL) && rookSq > A1_VAL) rookSq--;

            }
            else if (c == 'q'){
                rookSq = Square.flippedIfBlack(side, A1_VAL);
                while (getPiece(rookSq) != Piece.valueOf(side, ROOK_VAL) && rookSq < H1_VAL) rookSq++;
            }

            else if (c >= 'a' && c <= 'h')
                rookSq = Square.value(File.of(c), Rank.flippedIfBlack(side, Rank.RANK_1_VAL));
            else break; // c = "-"

            if (getPiece(rookSq) == Piece.valueOf(side, ROOK_VAL) && getPiece(kingSq) == Piece.valueOf(side, KING_VAL)) {
                int castleRight = rookSq > kingSq ? shortCastle(side) : longCastle(side);
                int destKing = isShortCastle(castleRight) ? Square.flippedIfBlack(side, G1_VAL) : Square.flippedIfBlack(side, C1_VAL);
                int destRook = isShortCastle(castleRight) ? Square.flippedIfBlack(side, F1_VAL) : Square.flippedIfBlack(side, D1_VAL);
                //update castle right info
                castlingRights += castleRight;
                castlingOptionsMask[rookSq] = ALL_CASTLING - castleRight;
                castlingDestSquareKing[rookSq] = destKing;
                castlingDestSquareRook[rookSq] = destRook;
                castlingKingPath[rookSq] = pathBetween(kingSq, destKing) & ~squareToBB(kingSq);
                castlingPath[rookSq] = castlingKingPath[rookSq] | pathBetween(rookSq, destRook) & ~squareToBB(rookSq);
                castlingMoves[castleRight] = createMove(kingSq, rookSq, CASTLING);
            }
        }
        state.castlingRights = castlingRights;
        return castlingRights;

    }

//    public void setFen(String fen, PositionState state){
//        this.state = state;
//        int[] copy_Board = new int[Square.VALUES_COUNT];
//        int[] pii = new int[12];
//
//        System.arraycopy(board, 0, copy_Board, 0, board.length);
//    }

    /**
     * Generates and returns the Forsyth–Edwards Notation (FEN) string representation valueOf the current chess position.
     * The FEN string includes information about the board, side to move, castling rights, en passant square,
     * half-move clock, and full-move number.
     *
     * @return FEN string representation valueOf the current position
     */
    public String getFen() {
        StringBuilder boardFen = new StringBuilder(); // FEN for the board state
        StringBuilder CFen = new StringBuilder();   // FEN for castling rights
        int piece;
        int numEmptySq = 0;

        // Loop over all the ranks on the board from black side to white side
        for (int square = A1_VAL; square <= H8_VAL; ++square) {
            if ((piece = getPiece(Square.flipped(square))) != NO_PIECE_VAL) {
                boardFen.append(numEmptySq != 0 ? numEmptySq : "").append(Piece.charName(piece));
                numEmptySq = 0;
            }
            else
                numEmptySq++;

            if (squareFile(Square.flipped(square)) == FILE_H_VAL) { // Check if it's the last square in a rank
                boardFen.append(numEmptySq != 0 ? numEmptySq : "").append(square == H8_VAL ? "" : "/");
                numEmptySq = 0;
            }
        }

        // Calculate the castling FEN
        if (canCastle(WHITE_SHORT))
            CFen.append(isChess960 ? Character.toUpperCase(File.charName(castlingRookFile(WHITE_SHORT))) : "K");
        if (canCastle(WHITE_LONG))
            CFen.append(isChess960 ? Character.toUpperCase(File.charName(castlingRookFile(WHITE_LONG))) : "Q");
        if (canCastle(BLACK_SHORT))
            CFen.append(isChess960 ? File.charName(castlingRookFile(BLACK_SHORT)) : "k");
        if (canCastle(BLACK_LONG))
            CFen.append(isChess960 ? File.charName(castlingRookFile(BLACK_LONG)) : "q");
        if (state.castlingRights == 0)
            CFen.append("-");

        String enPassant = enPassant() == NO_SQUARE_VAL ? "-" : Square.stringName(enPassant());

        // Format and return the complete FEN string
        return String.format("%s %c %s %s %d %d", boardFen, Side.charOf(sideToMove),
                CFen, enPassant, state.rule50, getNumMoves());
    }

    /**
     * Checks if a specific castling right is allowed in the current position.
     *
     * @param castlingRights the castling right to check (e.g., WHILE_SHORT, WHITE_LONG, BLACK_SHORT, BLACK_LONG)
     * @return true if the castling right is allowed, false otherwise
     */
    public boolean canCastle(int castlingRights) {
        return (state.castlingRights & castlingRights) != 0;
    }

    public boolean canCastle(int side, boolean isLong) {
        return canCastle(Castling.castlingRight(side, isLong));
    }

    public boolean canCastle(boolean isLong) {
        return canCastle(Castling.castlingRight(sideToMove, isLong));
    }

    /**
     * Gets the side to move in the current position.
     *
     * @return the side to move (WHITE_VAL or BLACK_VAL)
     */
    public int sideToMove() {
        return sideToMove;
    }


    /**
     * Makes a legal chess move in the current position and updates the internal state accordingly.
     * Assumes that the move is legal and follows the chess rules.
     * <p>
     * The process involves the following key steps:
     * 1. Update the new state:
     * - Initialize a new state to represent the position after the move.
     * - Update various aspects valueOf the position, such as captured pieces, en passant squares,
     * the rule 50 counter, and the position key. This sets up the new state for further modifications.
     * - Handle castling rights and update the castling key if needed.
     * - Establish the new state as the current state for subsequent updates.
     * <p>
     * 2. Update the board:
     * - Handle different move types, such as normal moves, castling, en passant, pawn promotions, etc.
     * - Move, capture, and promote pieces on the board.
     * - Update en passant squares and the rule 50 counter as needed.
     * - Ensure accurate tracking valueOf captured pieces.
     * <p>
     * 3. Update king data info:
     * - Update information related to the king, such as its square, checkers, and pinned pieces.
     * - Ensure the internal state accurately reflects the current board configuration.
     * <p>
     * 4. Update repetition information:
     * - Handle the threefold repetition rule to determine if the same position has occurred thrice.
     * <p>
     * 5. Record the last move made in the state.
     *
     * @param move the encoded representation valueOf the move
     *             //     * @param newState  the new state representing the position after the move
     */
    public void makeMove(int move) { // todo try to valueOf the new state inside this func
        // Assertion checks for move legality
        assert isPseudoLegalMove(move) : moveName(move) + "\n" + posString();
        assert isLegalMove(move) : moveName(move) + "\n" + posString();
//        PositionState newState = new PositionState(); // todo i i add this line its is fuster by 1 second

        int start = startSquare(move);
        int dest = destSquare(move);
        int moveType = moveType(move);
        int sideMoved = sideToMove;
        int sideMovedKSq = state.kingSquare;

        PositionState newState = new PositionState();

        // 1: Update the new state.
        // This involves updating various aspects valueOf the position, such as captured pieces, en passant squares,
        // the rule 50 counter, and the position key. It sets up the new state for further modifications.
        newState.capturedPiece = NO_PIECE_VAL;
        newState.enPassant = NO_SQUARE_VAL;
        newState.rule50 = state.rule50 + 1;

        newState.ply = state.ply + 1;
        newState.castlingRights = state.castlingRights;
        newState.key = state.key ^ enPassantKeys[state.enPassant] ^ colorKey;

        // Update castling key if needed and update castling rights
        if (state.castlingRights != 0 && (state.castlingRights &
                castlingOptionsMask[start] & castlingOptionsMask[dest]) != state.castlingRights) {
            newState.castlingRights &= (castlingOptionsMask[start] & castlingOptionsMask[dest]);
            newState.key ^= (castlingKeys[state.castlingRights] ^ castlingKeys[newState.castlingRights]);
        }

        // Update the state. This must be called before the board update because the removeNode-add-move piece method
        // changes the key valueOf the state. It establishes the new state as the current state for subsequent updates.
        newState.previous = state;
        state = newState;
        sideToMove = Side.flipped(sideToMove);
        numMoves++;

        // 2: Update the board
        // This section handles different move types, such as normal moves, castling, en passant, pawn promotions, etc.
        // It involves moving, capturing, and promoting pieces on the board, as well as updating en passant squares.

        // can not check if getPiece(dest) != NO_PIECE becuse castling move also decoded as a king capture rook.
//        if ((squareToBB(dest) & occupancyBySideBB[sideToMove]) != 0) {
        int pieceOnDest = getPiece(dest);
        if (pieceOnDest != NO_PIECE_VAL && moveType != CASTLING) { // not include enpassant that we handle letter
            state.capturedPiece = pieceOnDest;
            state.rule50 = 0;
            removePiece(dest);
        }
        {
            // temp
//            if (type(getPiece(start)) == PAWN_VAL){
//                assert (Square.distance(start, dest) == 16) == ((start ^ dest) == 16);
//                state.rule50 = 0;
//                if (moveType == NORMAL){
//                    movePiece(start, dest);
//                }
//
//                else if ((start ^ dest) == 16) { // push twice
//                    movePiece(start, dest);
//                    int epSquare = start + forward(sideMoved);
////                    state.enPassant = (occupancyByType(sideToMove, PAWN_VAL) & pawnAttacks(
////                            sideMoved, epSquare)) == 0 ? NO_SQUARE_VAL : epSquare;
////                    state.key ^= enPassantKeys[state.enPassant]; // in case valueOf epSquare == NO_SQUARE_VAL, it does nothing.
//                    if ((occupancyByType(sideToMove, PAWN_VAL) & pawnAttacks(sideMoved, epSquare)) != 0){
//                        state.enPassant = epSquare;
//                        state.key ^= enPassantKeys[state.enPassant];
//                    }
//                }
//
//                else if (moveType == Move.EN_PASSANT) {
//                    removePiece(dest - forward(sideMoved));
//                    movePiece(start, dest);
//                    // todo maybe update the capturing piece
//                }
//
//                else if (moveType == Move.PROMOTION) {
//                    addPiece(Piece.valueOf(sideMoved, promotePT(move)), dest);
//                    removePiece(start);
//                }
//            }
        }

        if (moveType == NORMAL) {
            movePiece(start, dest);
        }
        else if (moveType == NORMAL_PAWN_MOVE) {
            movePiece(start, dest);
            state.rule50 = 0;
        }
        else if (moveType == Move.PAWN_PUSH_TWICE) {
            movePiece(start, dest);
            int epSquare = start + forward(sideMoved);
            state.enPassant = (occupancyByType(sideToMove, PAWN_VAL) & pawnAttacks(
                    sideMoved, epSquare)) == 0 ? NO_SQUARE_VAL : epSquare;
            state.key ^= enPassantKeys[state.enPassant]; // in case valueOf epSquare == NO_SQUARE_VAL, it does nothing.
            state.rule50 = 0;
        }
        // Castling move encoded dest to sq valueOf rook
        else if (moveType == Move.CASTLING) {
            movePiece(start, castlingDestSquareKing[dest]);
            movePiece(dest, castlingDestSquareRook[dest]);
        }
        else if (moveType == Move.EN_PASSANT) {
            int captureSq = dest - forward(sideMoved);
            state.capturedPiece = getPiece(captureSq);

            removePiece(captureSq);
            movePiece(start, dest);

            state.rule50 = 0;

            // todo maybe update the capturing piece
        }

        else if (moveType == Move.PROMOTION) {
            addPiece(Piece.valueOf(sideMoved, promotePT(move)), dest);
            removePiece(start);
            state.rule50 = 0;
        }

        // 3: Update king data info
        // This section updates information related to the king, such as its square, checkers, and pinned pieces.
        // It ensures the internal state accurately reflects the current board configuration.
        int kingSq = squareOf(sideToMove, KING_VAL);
        state.kingSquare = kingSq;
        state.checkers = attackersBB(sideMoved, kingSq, occupancyBB);
        state.pinMask = pinMask(Side.flipped(sideToMove), kingSq);
//        state.pinMask2[] = pinMask(Side.flipped(sideToMove), squareOf(Side.flipped(sideToMove), KING_VAL));

        state.pinMask2[sideToMove]= pinMask(sideMoved, state.kingSquare);
        state.pinMask2[sideMoved]= pinMask(sideToMove, sideMovedKSq);
//        Time/: 42.70440125 with
//        Time: 42.983446958 without 42.46
        // Update repetition information to handle threefold repetition rule
        updateRepetition();

        // Record the last move made in the state
        state.lastMove = move;

        // Ensure the resulting position is legal
        assertPositionIsLegal();
    }




    /**
     * Undoes the last chess move in the current position and reverts the internal state accordingly.
     * Assumes that the move is legal and has been previously made using the makeMove method.
     */
    public void undoMove() {
        int move = state.lastMove;
        assert move != NULL_MOVE;

        int start = startSquare(move);
        int dest = destSquare(move);
        int moveType = moveType(move);

        // 1: Revert the board
        // This section handles different move types, such as normal moves, castling, en passant, pawn promotions, etc.
        // It involves moving, un capturing, and demoting pieces on the board to their original positions.
        if (moveType == NORMAL || moveType == NORMAL_PAWN_MOVE || moveType == PAWN_PUSH_TWICE)
            movePiece(dest, start);

        else if (moveType == Move.CASTLING) {
            movePiece(castlingDestSquareKing[dest], start);
            movePiece(castlingDestSquareRook[dest], dest); // Move the rook back to its original square
        }
        else if (moveType == Move.EN_PASSANT) {
            // In en passant moves, state.capturedPiece is encoded as Piece.NO_PIECE
            // Un capture the pawn and move it back to its original square
//            addPiece(Piece.flipped(getPiece(dest)), dest + Direction.forward(sideToMove));
            movePiece(dest, start);
            dest = dest + Direction.forward(sideToMove); // override dest to add the captured pawn on right place
        }
        else if (moveType == Move.PROMOTION) {
            // Demote the promoted piece back to a pawn and add the original piece back to its square
            addPiece(Piece.valueOf(Side.flipped(sideToMove), PAWN_VAL), start);
            removePiece(dest);
        }

        // If a piece was captured during the move, add it back to its original square
        if (state.capturedPiece != NO_PIECE_VAL)
            addPiece(state.capturedPiece, dest);

        // 2: Revert data
        // This section updates information related to the side to move, the number valueOf moves, and the position state.
        sideToMove = Side.flipped(sideToMove);
        --numMoves;
        state = state.previous;
//        --positionCount[(int) (state.key & positionCountMask)];

        // 3: Ensure the resulting position is legal
        assertPositionIsLegal();
    }


    /**
     * Retrieves the piece at the specified square.
     *
     * @param square the square to query
     * @return the piece at the specified square
     */
    public int getPiece(int square) {
        return board[square];
    }

    /**
     * Retrieves the square valueOf the specified piece type belonging to the given side.
     *
     * @param side      the side (color) valueOf the piece
     * @param pieceType the type valueOf the piece (e.g., KING_VAL, QUEEN_VAL)
     * @return the square valueOf the specified piece type for the given side
     */
    public int squareOf(int side, int pieceType) {
        return lsbToSquare(occupancyByPieceBB[Piece.valueOf(side, pieceType)]);
    }

    /**
     * Retrieves the square valueOf the specified piece.
     *
     * @param piece the piece to query
     * @return the square valueOf the specified piece
     */
    public int squareOf(int piece) {
        return lsbToSquare(occupancyByPieceBB[piece]);
    }

    /**
     * Retrieves the square valueOf the king for side to move.
     *
     * @return the square valueOf the king
     */
    public int kingSquare() {
        return state.kingSquare;
    }



    /**
     * Retrieves a bitboard with the pieces attacking a given square, considering the specified occupancy.
     *
     * @param square    the square to check for attackers
     * @param occupancy the bitboard representing the occupied squares
     * @return a bitboard with the pieces attacking the specified square
     */
    public long attackersBB(int square, long occupancy) {
        return (rookAttacks(square, occupancy) & occupancyByType(ROOK_VAL, QUEEN_VAL))      |
                (bishopAttacks(square, occupancy) & occupancyByType(BISHOP_VAL, QUEEN_VAL)) |
                (knightAttacks(square) & occupancyByType(KNIGHT_VAL))                       |
                (kingAttacks(square) & occupancyByType(KING_VAL))                           |
                (pawnAttacks(WHITE_VAL, square) & occupancyByPiece(BLACK_PAWN_VAL))         |
                (pawnAttacks(BLACK_VAL, square) & occupancyByPiece(WHITE_PAWN_VAL));
    }

    /**
     * Retrieves a bitboard with the pieces attacking a given square, considering the specified occupancy,
     * but restricted to a specific side (color).
     *
     * @param attacksSide the side (color) valueOf the attacking pieces
     * @param square      the square to check for attackers
     * @param occupancy   the bitboard representing the occupied squares
     * @return a bitboard with the pieces valueOf the specified side attacking the specified square
     */
    public long attackersBB(int attacksSide, int square, long occupancy) {
        return occupancyBySideBB[attacksSide] & attackersBB(square, occupancy);
    }

    public long attackersByPiece(int piece, int square){
        return attackersBB(square, occupancyBB) & occupancyByPiece(piece);
    }


    /**
     *
     * @param side white or black
     * @return the castling move by those parameter.
     */
    public int castlingMove(int side, boolean isLong){
        return castlingMove(Castling.castlingRight(side, isLong));
    }

    public int castlingMove(boolean isLong){
        return castlingMove(sideToMove, isLong);
    }



    public int castlingMove(int castleRight){
        return castlingMoves[castleRight];
    }


    /**
     * Checks if a chess move is pseudo-legal based on the following conditions:
     * <ol>
     *   <li>Verify if the side to move corresponds to the side valueOf the moving piece.</li>
     *   <li>Ensure that the piece can move according to the occupancy on the board.</li>
     *   <li>Check if the move corresponds to the allowed directions for the piece.</li>
     *   <li>Verify if the move type is valid for the given piece.</li>
     *   <li>Check if the move cancels a check on the position (not checking if the moved piece is on pin).</li>
     * </ol>
     *
     * @param move The encoded representation valueOf the move to be checked.
     * @return {@code true} if the move is pseudo-legal, {@code false} otherwise.
     */
    public boolean isPseudoLegalMove1(int move) {
        // Step 0: Extract relevant information from the move
        int start = startSquare(move);
        int dest = destSquare(move);
        int piece = getPiece(start);
        int pieceSide = Piece.side(piece);
        int moveType = moveType(move);
        int pt = Piece.type(piece);
        int promotePt = promotePT(move);

        // Step 1 : Check piece is exist on move start and check if the side to move corresponds to the piece side.
        // and check the promotion piece type set correctly
        if (piece == NO_PIECE_VAL ||
                pieceSide != sideToMove ||
                moveType != PROMOTION && promotePt != NO_PIECE_TYPE_VAL||
                (moveType == PROMOTION && (promotePt == NO_PIECE_TYPE_VAL || promotePt == PAWN_VAL || promotePt == KING_VAL)))
            return false;



        // Step 2, 3: Check if the piece can move according to the occupancy on the board
//        long enemy = occupancyBySide(flipped(sideToMove));
//        long empty = ~occupancyBB;
//        long target = pt != PAWN_VAL ? enemy | empty :
//                squareFile(start) == squareFile(dest) ? empty : enemy;
        if (moveType == NORMAL  || moveType == PAWN_PUSH_TWICE || moveType == PROMOTION || moveType == NORMAL_PAWN_MOVE) {
            if ((attacksAndMoves(sideToMove, pt, start, occupancy(), occupancyBySide(Side.flipped(pieceSide))) & squareToBB(dest)) == 0)
                return false;
        }

        // Step 4: Check if the move corresponds to the direction that the piece can walk
        else if (moveType == CASTLING) {

            int castleRight = start < dest ? shortCastle(sideToMove) : longCastling(sideToMove);
            if (/*state.checkers != 0 ||*/
                    ((castleRight & state.castlingRights) == 0) ||
                    castlingMoves[castleRight] != move) // This validates that start contains king and dest contains rook.
                return false;
        }

        // Step 4: Check validation valueOf en passant move.
        else if (moveType == EN_PASSANT) {
            // check if you can reach dest square from start by doing en passant walk, and addition check if the destination square are empty
            if (pt != PAWN_VAL || dest != state.enPassant ||
                    (pawnAttacks(sideToMove, start) & squareToBB(dest) & ~occupancyBB) == 0)
                return false;
            // in check, we need to end the function here because the check down not cover all the
            // cases valueOf en passant move leave own king in check.
//            if (inCheck())
//                return isLegalEnPassantMove(move);
        }

        // Step 5: Check if the position is in check and if the piece move cancels this check
        // (not checking if the piece moved is on pin)
//        if (state.checkers != 0) {
//            long checkMask = pathBetween(state.kingSquare, lsbToSquare(state.checkers));
//            return type(piece) == KING_VAL ?
//                    attackersBB(flipped(sideToMove), dest, occupancyBB ^ squareToBB(state.kingSquare)) == 0 :
//                    hasOneBit(state.checkers) && (checkMask & squareToBB(dest)) != 0;
//        }

        return true; // If all checks pass, the move is considered pseudo-legal
    }



    public boolean isLegalMove2(int move) {
        int start = startSquare(move);
        int dest = destSquare(move);
        int moveType = moveType(move);
        int pieceMoved = getPiece(start);
        int ksq = state.kingSquare;
        int enemySide = Side.flipped(sideToMove);

        if (moveType == NORMAL || moveType == PAWN_PUSH_TWICE || moveType == PROMOTION || moveType == NORMAL_PAWN_MOVE) {
            // In case valueOf the king move, check if the destination square is safe.
            return (Piece.type(pieceMoved) == KING_VAL) ?
                    attackersBB(enemySide, dest, occupancyBB ^ squareToBB(ksq)) == 0 :
                    ((squareToBB(start) & state.pinMask) == 0) || onSameLine(start, dest, ksq); // check if this piece is pined and in case valueOf pined if it can move along pin line.
        }

        // Here, move type must be either EN_PASSANT or CASTLING.
        return moveType == CASTLING ? isLegalCastlingMove(move) : isLegalEnPassantMove(move);
    }


//    public boolean isFullyLegalMove(int start, int dest, int promoteType) {
//        return isFullyLegalMove(toMove(start, dest, promoteType));
//    }

    // uci move represents castling in not cess960 as king startSq to king destSq.
    // so in that case we need to change the king dest square.
    public int toUciMove(int move){
        if (Move.moveType(move) == CASTLING && !isChess960()){
            int startSq = startSquare(move);
            int oldDest = destSquare(move);

            int newDestSq = Square.value(startSq < oldDest ? FILE_G_VAL : FILE_C_VAL, squareRank(startSq));
            return Move.createMove(startSq, newDestSq, CASTLING);
        }
        return move;
    }

    public int fromUciMove(int sqStart, int sqDest , int promotePT){
        return toMove(sqStart, sqDest, promotePT);
    }


    public int fromUciMove(int move){
        return toMove(startSquare(move), destSquare(move), promotePT(move));
    }

    // ============         move validateion         =============

    // assume is legal move, convert engine normal (not chess960) castling move to king capture own rook represention.
    public int toMove(int sqStart, int sqDest , int promoteType){
        if (sqStart == kingSquare() && !isChess960 && Square.distance(sqStart, sqDest) == 2){
            return castlingMove(sideToMove, sqStart > sqDest);
        }
        return Move.createMove(sqStart, sqDest, getMoveType(sqStart, sqDest), promoteType);
    }

    public int getMoveType(int moveStart, int moveDest){
//        assert Square.isValid(moveStart) && Square.isValid(moveDest) && getPiece(moveStart) != NO_PIECE_VAL;
        int pieceMove = getPiece(moveStart);
        int pieceType = Piece.type(pieceMove);
        int side = Piece.side(pieceMove);

//        assert Square.isValid(moveStart) && Square.isValid(moveDest) && Piece.isValid(pieceMove);

        if (pieceType == PAWN_VAL) {
            return ((squareToBB(moveDest) & (RANK_1_BB | RANK_8_BB)) != 0) ?    PROMOTION :
                    Square.distance(moveStart, moveDest) == 16 ?          PAWN_PUSH_TWICE :
                    moveDest == enPassant() ?                                  EN_PASSANT :
                                                                          NORMAL_PAWN_MOVE;
        }
        // as long castling mark as king capture his rook not need to check another conditions like the king move 2 square.
        return Piece.valueOf(side, ROOK_VAL) == getPiece(moveDest) ? CASTLING : NORMAL;
    }


    /**
     * Checks if a chess move is pseudo-legal based on the following conditions:
     * <ol>
     *   <li>Verify if the side to move corresponds to the side valueOf the moving piece.</li>
     *   <li>Ensure that the piece can move according to the occupancy on the board.</li>
     *   <li>Verify if the move type is valid for the given piece.</li>
     * </ol>
     *
     * @param move The encoded representation valueOf the move to be checked.
     * @return {@code true} if the move is pseudo-legal, {@code false} otherwise.
     */
    public boolean isPseudoLegalMove(int move) {
        int start = startSquare(move);
        int dest = destSquare(move);
        int piece = getPiece(start);
        int pieceSide = Piece.side(piece);
        int moveType = moveType(move);
        int pt = Piece.type(piece);
        int promotePt = promotePT(move);
        long enemyBB = occupancyBySide(Side.flipped(pieceSide));

        // simple validation that has piece on start. the correct side move and in not promotion move, promote piece type set to 0.
        if (piece == 0 || pieceSide != sideToMove || (promotePt != 0 && moveType != PROMOTION)){
            return false;
        }
        if (moveType == NORMAL) {
            return ((attacks(pt, start, occupancy()) & (enemyBB | ~occupancy())) & squareToBB(dest)) != 0;
        }
        if (pt == PAWN_VAL && Move.isPawnMoveType(moveType)){
            int direction = forward(pieceSide);

            if (moveType == EN_PASSANT){
                // check if you can reach dest square from start by doing en passant walk, and addition check if the destination square are empty
                return dest == state.enPassant && (pawnAttacks(sideToMove, start) & squareToBB(dest) & ~occupancyBB) != 0;
            }
            if (moveType == PAWN_PUSH_TWICE) {
                return squareRank(start) == Rank.flippedIfBlack(pieceSide, RANK_2_VAL)  &&
                        dest == start + 2*direction &&
                        getPiece(start + direction) == NO_PIECE_VAL &&
                        getPiece(start + 2*direction) == NO_PIECE_VAL;
            }
            if (moveType == PROMOTION){
                if (!(promotePt == BISHOP_VAL || promotePt == ROOK_VAL || promotePt == KNIGHT_VAL || promotePt == QUEEN_VAL)
                        || squareRank(dest) != Rank.flippedIfBlack(pieceSide, RANK_8_VAL)){
                    return false;
                }
            }
            return squareFile(start) == squareFile(dest) ? // is push move
                    dest == start + direction && getPiece(dest) == NO_PIECE_VAL :
                    (pawnAttacks(sideToMove, start) & squareToBB(dest) & enemyBB) != 0;
        }

        if (moveType == CASTLING){
            int castleRight = start < dest ? shortCastle(sideToMove) : longCastling(sideToMove);
            // This validates that start contains king and dest contains rook.
            return ((castleRight & state.castlingRights) != 0) && castlingMoves[castleRight] == move;
        }
        return false; // if we reach here moveType is on valueOf the pawns move type and piece is not pawn.
    }


    /**
     * Checks if a chess move is legal, considering the move's pseudo-legality and additional conditions.
     * Assumes the move is pseudo-legal.
     * pseudo legal move consider legal if it's not leave own king under threat. (the move must cancel
     * check if any, and make sure the move itself not valueOf new threat in case valueOf pin piece moved.)
     *
     * @param move The encoded representation valueOf the move.
     * @return True if the move is legal, false otherwise.
     */
    public boolean isLegalMove(int move) {
        int moveType = moveType(move);

        if (moveType == CASTLING)
            return isLegalCastlingMove(move);

        if (moveType == EN_PASSANT)
            return isLegalEnPassantMove(move);

        int start = startSquare(move);
        int dest = destSquare(move);
        int ksq = state.kingSquare;
        // In case valueOf the king move, check if the destination square is safe.
        if (start == ksq)
            return attackersBB(Side.flipped(sideToMove), dest, occupancyBB ^ squareToBB(ksq)) == 0;
        // Make sure the move doesn't leave the king in check.
        // First, check for double check — in that case, only king moves are legal, and since we already returned if king moved, return false.
        // Otherwise, there's only one checker, so calculate the path mask and check if the destination square blocks the check.
        long checkers = state.checkers;
        if (checkers != 0 && (
                has2OrMoreBits(checkers) || (pathBetween(ksq, lsbToSquare(checkers)) & squareToBB(dest)) == 0))
            return false;

        // check if this piece is pined and in case valueOf pined if it can move along pin line.
        return ((squareToBB(start) & state.pinMask) == 0) || onSameLine(start, dest, ksq);
//
//        if (moveType == NORMAL || moveType == PAWN_PUSH_TWICE || moveType == PROMOTION || moveType == NORMAL_PAWN_MOVE) {
//            // In case valueOf the king move, check if the destination square is safe.
//            if (type(pieceMoved) == KING_VAL)
//                   return attackersBB(enemySide, dest, occupancyBB ^ squareToBB(ksq)) == 0;
//            // make sure that the piece move not leave own king under threat.
//            long checkMask = pathBetween(ksq, lsbToSquare(state.checkers));
//            if (inCheck() && (has2OrMoreBits(state.checkers) || (checkMask & squareToBB(dest)) == 0))
//                return false;
//            // check if this piece is pined and in case valueOf pined if it can move along pin line.
//            return ((squareToBB(start) & state.pinMask) == 0) || onSameLine(start, dest, ksq);
//        }
//
//        // Here, move type must be either EN_PASSANT or CASTLING.
//        return moveType == CASTLING ? isLegalCastlingMove(move) : isLegalEnPassantMove(move);
    }

    /**
     * Checks if a chess move is fully legal
     *
     * @param move The encoded representation valueOf the move.
     * @return True if the move is legal, false otherwise.
     */
    public boolean isFullyLegalMove(int move) {
        return isPseudoLegalMove(move) && isLegalMove(move);
    }




    /**
     * Checks if a castling move is legal.
     * Assumes the move is pseudo-legal.
     *
     * @param move castling move
     * @return True if the castling move is legal, false otherwise.
     */
    public boolean isLegalCastlingMove(int move) {
        int dest = destSquare(move); // dest is the square that the castling rook on it.
        // king can not be in a check and all castling path must be empty.
        if (state.checkers != 0 || (castlingPath[dest] & occupancyBB) != 0) return false;

        int enemySide = Side.flipped(sideToMove);
        long kingPath = castlingKingPath[dest];

        // loop over all the square in castling king path and check if the enemy threatening them.
        for (;kingPath != 0; kingPath = popLsb(kingPath))
            if (attackersBB(enemySide, lsbToSquare(kingPath), occupancyBB) != 0) return false;

        // to include the case of chess 960 that calling rook pin to the king,
        // for example enemy queen on a1 rook on b1 and king on c1
        return (squareToBB(dest) & state.pinMask) == 0;
    }

    /*
    //        return attackersBB(enemySide, ksq, occAfterMove) == 0;
    a5a4: 239316146
a5a6: 270853688
e2e3: 193659561
g2g3: 76018380
e2e4: 147506250
g2g4: 229481895
b4b1: 334238252
b4b2: 220015036
b4b3: 255018754
b4a4: 203218268
b4c4: 289573614
b4d4: 265831872
b4e4: 232703176
b4f4: 50516708
Nodes count: 3007951600
Time: 49.671382125
     */

    /**
     * Checks if an en passant move is legal.
     * Assumes the move is pseudo-legal.
     *
     * @param epMove
     * @return True if the en passant move is legal, false otherwise.
     */
    public boolean isLegalEnPassantMove(int epMove) {


//        assert !inCheck();
//        if (inCheck() && (state.checkers & occupancyBySideAndType(Side.flipped(sideToMove), KNIGHT_VAL)) != 0){
//            System.out.println();
//        }
        int start = startSquare(epMove);
        int dest = destSquare(epMove);
        int ksq =  state.kingSquare;
        int enemySide = Side.flipped(sideToMove);
        int captureSq = dest - forward(sideToMove);
        long occAfterMove = occupancyBB ^ squareToBB(start) ^ squareToBB(dest) ^ squareToBB(captureSq);

//        return (attackersBB(enemySide, ksq, occAfterMove) & ~squareToBB(captureSq)) == 0; // this line fail in the test
//        // for example when enemy pawn push twice to attack our king, the enpassant capture this pawn.
//        // but the resuolt of this function consider this pawn

//        if (inCheck()){
//            return (attackersBB(enemySide, ksq, occAfterMove) & ~squareToBB(captureSq)) == 0; // this line fail in the test
//        }
        return (rookAttacks(ksq, occAfterMove) & occupancyBySideAndType(enemySide, ROOK_VAL, QUEEN_VAL)) == 0 &&
                (bishopAttacks(ksq, occAfterMove) & occupancyBySideAndType(enemySide, BISHOP_VAL, QUEEN_VAL)) == 0;
    }

    public PositionState getState(){
        return state;
    }

    // return the piece that is captured during the last move
    public int getCapturedPiece(){
        return state.capturedPiece;
    }

//    public boolean isCapturingFromLastMove(){
//        return state.capturedPiece != NO_PIECE_VAL ||
//    }

    /**
     * Checks if the current board state represents insufficient material for a checkmate.
     * Conditions checked:
     * 1. Cover the case valueOf:
     *    - King vs King
     *    - King vs King + Knight or Bishop
     *    - King vs King + 2 Bishops with the same color.
     * 2. Ensure that the remaining pieces cannot deliver checkmate.
     * 3. Ensure that the remaining bishops are on the same color.
     *
     * @return True if the material is insufficient for checkmate, false otherwise.
     */
    public boolean inInsufficientMaterial() {
        return (numPieces <= 4 &&
                occupancyByType(QUEEN_VAL, ROOK_VAL, PAWN_VAL) == 0) &&
                Bitboard.isOnSameColor(occupancyByType(BISHOP_VAL));
    }


    public boolean inCheck(){
        return state.checkers != 0;
    }
    public boolean isMoveGiveCheck2(int move) {
        int start = startSquare(move);
        int dest = destSquare(move);
        int moveType = moveType(move);
        int movingPiece = getPiece(start);
        int movingSide = Piece.side(movingPiece);
        int movingType = Piece.type(movingPiece);
        int enemySide = Side.flipped(movingSide);

        int oppKingSq = squareOf(enemySide, KING_VAL);

        // === Simulate occupancy after the move ===
        long newOcc = occupancyBB ^ squareToBB(start) | squareToBB(dest);

        // === Special handling for en passant ===
        if (moveType == EN_PASSANT) {
            int capturedSq = dest - forward(movingSide);
            newOcc ^= squareToBB(capturedSq); // Remove captured pawn
        }

        // === Check if the moved piece attacks the enemy king ===
        long attacks = attacks(movingType == PAWN_VAL && moveType == PROMOTION ? promotePT(move) : movingType,
                dest, newOcc);

        if ((attacks & squareToBB(oppKingSq)) != 0)
            return true;

        // === Check for discovered check (revealed check) ===
        long between = Bitboard.pathBetween(dest, oppKingSq);
        if (between != 0 && (between & squareToBB(start)) != 0) {
            // The piece moved was on a line to the king
            // Check if any piece from our side behind `start` now gives check
            long revealedAttackers = attackersBB(oppKingSq, newOcc) & occupancyBySide(movingSide);
            return revealedAttackers != 0;
        }

        return false;
    }

    public boolean isMoveGiveCheck(int move){
        int startSq = Move.startSquare(move);
        int destSq = Move.destSquare(move);

        int piece = getPiece(startSq);
        int side = sideToMove;

        int enemyKsq = squareOf(Side.flipped(side), KING_VAL);


        // in castling need to convert dest to rook dest
        // in promotion need to conver piece to promote piece
        // in en passant its way to far complicated


        long oppKingSqBB = Bitboard.squareToBB(enemyKsq);
        long pathToKing = pathBetween(destSq, enemyKsq);

        int moveType = Move.moveType(move);
        if (moveType != NORMAL) {
            if (moveType == PROMOTION) {
                piece = Piece.valueOf(side, promotePT(move));
            }
            else if (moveType == CASTLING){
                destSq = castlingDestSquareRook[destSq];
            }
            else if (moveType == EN_PASSANT){
                // simulate do, undo move
                int captureSq = destSq - forward(sideToMove);
                long occAfterMove = occupancyBB ^ squareToBB(startSq) ^ squareToBB(destSq) ^ squareToBB(captureSq);
                if ((rookAttacks(enemyKsq, occAfterMove) & occupancyBySideAndType(sideToMove, ROOK_VAL, QUEEN_VAL)) == 0 &&
                        (bishopAttacks(enemyKsq, occAfterMove) & occupancyBySideAndType(sideToMove, BISHOP_VAL, QUEEN_VAL)) == 0){
                    return false;
                }
            }
        }
        // base, is it direct or discover
        return
            // piece can reach to opponent king and there is no blocker.
            ((Bitboard.attacks(Piece.type(piece), destSq) & oppKingSqBB) != 0 && (pathToKing & occupancyBB) == oppKingSqBB)
                    // is discover check
            || ((squareToBB(startSq) & state.pinMask2[Side.flipped(sideToMove)]) != 0 && !onSameLine(startSq, destSq, enemyKsq));
    }


    public long pinMask(int attackSide, int targetSquare){
        // all attackers around (on file, rank and tow diagonal valueOf targetSquare square) the square targetSquare
        long attackers =
                (occupancyBySideAndType(attackSide, BISHOP_VAL, QUEEN_VAL) & bishopAttacks(targetSquare)) |
                        (occupancyBySideAndType(attackSide, ROOK_VAL, QUEEN_VAL)   & rookAttacks(targetSquare));
        long pinMask = 0, pathToS, occupancy =  occupancyBB ^ attackers;

        for ( ;attackers != 0; attackers = Bitboard.popLsb(attackers)) {
            int square = lsbToSquare(attackers);
            pathToS = Bitboard.pathBetween(targetSquare, square);
            if (Bitboard.hasOneBit(pathToS & occupancy))
                pinMask |= pathToS;
        }
        return pinMask;
    }

// occupancy methods:
    /**
     * Get the bitboard representing the occupancy valueOf all pieces on the board.
     *
     * @return The bitboard representing the occupancy.
     */
    public long occupancy() {
        return occupancyBB;
    }

    /**
     * Get the bitboard representing the occupancy valueOf a specific side on the board.
     *
     * @param side The side (WHITE or BLACK) for which to get the occupancy.
     * @return The bitboard representing the occupancy valueOf the specified side.
     */
    public long occupancyBySide(int side) {
        return occupancyBySideBB[side];
    }

    /**
     * Get the bitboard representing the occupancy valueOf a specific piece type on the board.
     *
     * @param pieceType The piece type for which to get the occupancy.
     * @return The bitboard representing the occupancy valueOf the specified piece type.
     */
    public long occupancyByType(int pieceType) {
        return occupancyByTypeBB[pieceType];
    }

    /**
     * Get the bitboard representing the combined occupancy valueOf two piece types on the board.
     *
     * @param pieceType1 The first piece type.
     * @param pieceType2 The second piece type.
     * @return The combined bitboard representing the occupancy valueOf the specified piece types.
     */
    public long occupancyByType(int pieceType1, int pieceType2) {
        return occupancyByTypeBB[pieceType1] | occupancyByTypeBB[pieceType2];
    }

    /**
     * Get the bitboard representing the combined occupancy valueOf three-piece types on the board.
     *
     * @param pieceType1 The first piece type.
     * @param pieceType2 The second piece type.
     * @param pieceType3 The third piece type.
     * @return The combined bitboard representing the occupancy valueOf the specified piece types.
     */
    public long occupancyByType(int pieceType1, int pieceType2, int pieceType3) {
        return occupancyByTypeBB[pieceType1] | occupancyByTypeBB[pieceType2] | occupancyByTypeBB[pieceType3];
    }

    /**
     * Get the bitboard representing the occupancy valueOf a specific piece on the board.
     *
     * @param piece The piece for which to get the occupancy.
     * @return The bitboard representing the occupancy valueOf the specified piece.
     */
    public long occupancyByPiece(int piece) {
        return occupancyByPieceBB[piece];
    }

    /**
     * Get the bitboard representing the combined occupancy valueOf two specific pieces on the board.
     *
     * @param piece1 The first piece.
     * @param piece2 The second piece.
     * @return The combined bitboard representing the occupancy valueOf the specified pieces.
     */
    public long occupancyByPiece(int piece1, int piece2) {
        return occupancyByPieceBB[piece1] | occupancyByPieceBB[piece2];
    }

    /**
     * Get the bitboard representing the combined occupancy valueOf three specific pieces on the board.
     *
     * @param piece1 The first piece.
     * @param piece2 The second piece.
     * @param piece3 The third piece.
     * @return The combined bitboard representing the occupancy valueOf the specified pieces.
     */
    public long occupancyByPiece(int piece1, int piece2, int piece3) {
        return occupancyByPieceBB[piece1] | occupancyByPieceBB[piece2] | occupancyByPieceBB[piece3];
    }

    /**
     * Get the bitboard representing the occupancy valueOf a specific piece type on a specific side.
     *
     * @param side      The side (WHITE or BLACK) for which to get the occupancy.
     * @param pieceType The piece type for which to get the occupancy.
     * @return The bitboard representing the occupancy valueOf the specified piece type on the specified side.
     */
    public long occupancyBySideAndType(int side, int pieceType) {
        return occupancyByTypeBB[pieceType] & occupancyBySideBB[side];
    }

    /**
     * Get the bitboard representing the combined occupancy valueOf two piece types on a specific side.
     *
     * @param side      The side (WHITE or BLACK) for which to get the occupancy.
     * @param pieceType1 The first piece type.
     * @param pieceType2 The second piece type.
     * @return The combined bitboard representing the occupancy valueOf the specified piece types on the specified side.
     */
    public long occupancyBySideAndType(int side, int pieceType1, int pieceType2) {
        return occupancyBySideBB[side] & (occupancyByTypeBB[pieceType1] | occupancyByTypeBB[pieceType2]) ;
    }

    /**
     * Get the bitboard representing the squares pinned by the opponent's pieces.
     *
     * @return The bitboard representing pinned squares.
     */
    public long pinMask() {
        return state.pinMask;
    }

    /**
     * Get the bitboard representing the squares currently attacked by opponent pieces.
     *
     * @return The bitboard representing attacked squares.
     */
    public long checker() {
        return state.checkers;
    }

    /**
     * Check if a specific square is under attack by pieces valueOf the specified side.
     *
     * @param attackingSide The side (WHITE or BLACK) whose pieces are considered attackers.
     * @param square        The square to check for being under attack.
     * @return True if the square is under attack; otherwise, false.
     */
    public boolean squareUnderAttack(int attackingSide, int square) {
        return (occupancyBySideBB[attackingSide] & attackersBB(square, occupancyBB)) != 0;
    }

    /**
     * Get the en passant square, if any, from the current position state.
     *
     * @return The en passant square, or NO_SQUARE_VAL if there is no en passant square.
     */
    public int enPassant() {
        return state.enPassant;
    }

    /**
     * Get the current rule 50 count from the position state.
     *
     * @return The current rule 50 count.
     */
    public int rule50() {
        return state.rule50;
    }


    /**
     * Check if the position is in a state valueOf reaching the 50-move rule for a draw.
     *
     * @return True if the position is in the 50-move rule condition; otherwise, false.
     */
    public boolean inRule50() {
        return state.rule50 == RULE_50_COUNT_TO_DRAW;
    }

    /**
     * Get the last move made in the position.
     *
     * @return The last move made, encoded as an integer.
     */
    public int lastMove() {
        return state.lastMove;
    }


// private methods:
    /**
     * Adds a piece to the chessboard at the specified square.
     * Assumes the square is empty.
     *
     * @param piece  The piece to be added.
     * @param square The square where the piece is added.
     */
    void addPiece(int piece, int square){
        assert Piece.isValid(piece) && getPiece(square) == NO_PIECE_VAL;
        long sqBB = Bitboard.squareToBB(square);
        occupancyBB |= sqBB;
        occupancyBySideBB[Piece.side(piece)] |= sqBB;
        occupancyByTypeBB[Piece.type(piece)] |= sqBB;
        occupancyByPieceBB[piece] |= sqBB;
        board[square] = piece;
        numPieces++;
        state.key ^= pieceSquareKeys[piece][square];

    }

    /**
     * Removes a piece from the chessboard at the specified square.
     * Assumes the square is not empty.
     *
     * @param square The square from which the piece is removed.
     */
    void removePiece(int square){
        assert square != NO_SQUARE_VAL;
        long sqBB = Bitboard.squareToBB(square);
        int piece = board[square];
        occupancyBB ^= sqBB;
        occupancyBySideBB[Piece.side(piece)] ^= sqBB;
        occupancyByTypeBB[Piece.type(piece)] ^= sqBB;
        occupancyByPieceBB[piece] ^= sqBB;
        board[square] = NO_PIECE_VAL;
        numPieces--;
        state.key ^= pieceSquareKeys[piece][square];
    }

    /**
     * Moves a piece on the chessboard from the start square to the destination square.
     * Assumes there is a piece on the start square and the destination square is empty.
     * If start == dest, it has no effect.
     *
     * @param start The starting square valueOf the piece.
     * @param dest  The destination square for the piece.
     */
    private void movePiece(int start, int dest){
        assert getPiece(start) != NO_PIECE_VAL;
        long startOrDestBB = Bitboard.squareToBB(start) | Bitboard.squareToBB(dest);
        int piece = getPiece(start);
        occupancyBB ^= startOrDestBB;
        occupancyBySideBB[Piece.side(piece)] ^= startOrDestBB;
        occupancyByTypeBB[Piece.type(piece)] ^= startOrDestBB;
        occupancyByPieceBB[piece] ^= startOrDestBB;
        board[start] = NO_PIECE_VAL;
        board[dest] = piece;
        state.key ^= (pieceSquareKeys[piece][start] ^ pieceSquareKeys[piece][dest]);
    }

    /**
     * Update the repetition count in the current position state.
     * Checks for repetitions by comparing the position key.
     * If a repetition is found, increments the repetition count.
     */
    private void updateRepetition() {
        state.numRepetition = 0;
        int end = Math.min(state.rule50, state.ply);
        if (end >= 4) {
            PositionState step = state.previous.previous;
            for (int i = 4; i <= end; i += 2) {
                step = step.previous.previous;
                if (step.key == state.key) {
                    state.numRepetition = step.numRepetition + 1;
                    return;
                }
            }
        }
    }

    private boolean inVerifyRepetition() {
        Map<String, Integer> positionCount = new HashMap<>();

        String currentFen = getFen();
        PositionState currentState = state;

        positionCount.put(generateRepetitionByFenKey(currentFen), 1);

        boolean isVerified = false;
        int end = Math.min(state.rule50, state.ply);

        for (int i = 0; i < end && !isVerified; i++) {
            undoMove();
            String key = generateRepetitionByFenKey(getFen());
            int count = positionCount.merge(key, 1, Integer::sum);
            isVerified = count >= 3;
        }

        // Restore full state
        setFen(currentFen, isChess960);
        state = currentState; // Restore previous state chain (setFen resets it)

        return isVerified;

    }


    private static String generateRepetitionByFenKey(String fen) {
        String[] parts = fen.split(" ");
        return parts[0] + " " + parts[1] + " " + parts[2] + " " + parts[3]; // pieces, side, castling, ep
    }

    /**
     * Checks whether the position has occurred three times by verifying the actual
     * positions in the game history (repetition by FEN logic).
     *
     * This method is slower but guaranteed correct. It replays the move history
     * backwards (up to 50 moves) and compares the repetition-relevant fields of the FEN:
     * - piece placement
     * - side to move
     * - castling rights
     * - en passant square
     *
     * Use this method if you need a reliable draw detection, e.g. for PGN validation,
     * engine draw claims, or UI indication.
     *
     * @return true if the exact same position has occurred three times, false otherwise.
     */
    public boolean inVerifiedThreeFoldRepetition() { // todo to test it
        return inThreeFoldRepetition() && inVerifyRepetition();
    }

    /**
     * Quickly checks whether the current position is flagged internally as being in a state
     * of threefold repetition, based on Zobrist hash tracking.
     *
     * Note:
     * - This check is fast and efficient, using hash-based counting.
     * - However, due to the nature of Zobrist hashing (64-bit), false positives are
     *   theoretically possible due to collisions.
     * - Use {@link #inVerifiedThreeFoldRepetition()} for guaranteed correctness.
     *
     * @return true if the position has potentially occurred three times, false otherwise.
     */
    public boolean inThreeFoldRepetition() {
        return state.numRepetition >= NUM_REPETITION_TO_DRAW;
    }


    /**
     * Get the file valueOf the rook involved in castling.
     *
     * @param castleRight The castling right representing the castling move.
     * @return The file valueOf the rook involved in castling.
     */
    private int castlingRookFile(int castleRight) {
        return squareFile(destSquare(castlingMove(castleRight)));
    }

    /**
     * Asserts that the current position is legal, checking various conditions.
     * Used for debugging and testing purposes.
     */
    private void assertPositionIsLegal() {
        // Only one king for each side.
        assert hasOneBit(occupancyByPiece(WHITE_KING_VAL)) && hasOneBit(occupancyByPiece(BLACK_KING_VAL)) :
                "Invalid number valueOf kings";

        // Opponent side to move not in check.
        assert attackersBB(sideToMove, squareOf(Side.flipped(sideToMove), KING_VAL), occupancy()) == 0 :
                "King not in the side to move is under attack\n" + posString();

        // Pawn cannot be on the first or last rank.
        assert (occupancyByType(PAWN_VAL) & (RANK_1_BB | RANK_8_BB)) == 0 :
                "Pawn on first or last rank";

        // En passant validation was done by setFen method.

        // Check if the board representation is legal.
        for (int square = A1_VAL; square <= H8_VAL; ++square) {
            int piece = getPiece(square);
            assert piece != NO_PIECE_VAL || (squareToBB(square) & (occupancy() |
                    occupancyBySide(WHITE_VAL) | occupancyBySide(BLACK_VAL))) == 0 :
                    String.format("Piece on square %s, piece is %c - bitboards not synchronized.\n" + posString(),
                            Square.stringName(square), Piece.charName(piece));
            for (int pieceType : PieceType.allPieceTypesValues()) {
                if (pieceType == Piece.type(piece)) { // All bits need to be set.
                    assert (squareToBB(square) &
                            occupancy() &
                            occupancyBySide(Piece.side(piece)) &
                            occupancyByType(pieceType) &
                            ~occupancyByPiece(Piece.flipped(piece)) &
                            ~occupancyBySide(Side.flipped(Piece.side(piece))) &
                            occupancyByPiece(piece)) != 0 :
                            String.format("Piece on square %s, piece is %c - bitboards not synchronized.\n" + posString(),
                                    Square.stringName(square), Piece.charName(piece));
                } else { // All bits need to be empty.
                    assert (squareToBB(square) & (
                            occupancyByPiece(Piece.valueOf(WHITE_VAL, pieceType)) |
                                    occupancyByPiece(Piece.valueOf(BLACK_VAL, pieceType)) |
                                    occupancyByType(pieceType))) == 0 :
                            String.format("Piece on square %s, piece is %c - bitboards not synchronized.\n" + posString(),
                                    Square.stringName(square), Piece.charName(piece));
                }
            }
        }

        // Castling validation, check if all the castling rights given by the user are valid on the board.
        // in case valueOf normal chess make sure that the dest king and rook in the correct place.
        for (int castleRight : new int[]{WHITE_SHORT, WHITE_LONG, BLACK_SHORT, BLACK_LONG}) {
            if (canCastle(castleRight)) {
                int side = castlingSide(castleRight);
                boolean isShort = (isShortCastle(castleRight));
                int kSq = startSquare(castlingMoves[castleRight]);
                int rSq = destSquare(castlingMoves[castleRight]);
                assert getPiece(rSq) == Piece.valueOf(side, ROOK_VAL) &&
                        Rank.flippedIfBlack(side, RANK_1_VAL) == squareRank(kSq) && // King in the correct rank.
                        (isShort && kSq < rSq || !isShort && kSq > rSq) &&
                        (isChess960 || (rSq == Square.flippedIfBlack(side, isShort? H1_VAL: A1_VAL) && kSq == Square.flippedIfBlack(side, E1_VAL))):
                        "Castling rights invalid";
            }
        }
    }

    /**
     * Checks if the current chess position is legal based on various criteria.

     * Criteria Checked:
     * 1. Each side must have only one king on the board.
     * 2. The opponent side to move must not be in check.
     * 3. Pawns cannot be on the first or last rank.
     * 4. Board representation legality:
     *    - Pieces' bits must align with occupancy bitboards.
     *    - All bits corresponding to the piece must be set correctly.
     *    - Bits corresponding to other pieces and types must be empty.
     * 5. Castling validation:
     *    - Validates the legality valueOf castling moves given the castling rights.

     * Note: Assumes en passant validation was done during the setFen method.
     *
     * @return True if the position is legal, false otherwise.
     */
    public boolean positionIsLegal() {
        // 1. Each side must have only one king on the board.
        if (!hasOneBit(occupancyByPiece(WHITE_KING_VAL)) || !hasOneBit(occupancyByPiece(BLACK_KING_VAL)))
            return false;

        // 2. The opponent side to move must not be in check.
        if (attackersBB(sideToMove, squareOf(Side.flipped(sideToMove), KING_VAL), occupancy()) != 0)
            return false;

        // 3. Pawns cannot be on the first or last rank.
        if ((occupancyByType(PAWN_VAL) & (RANK_1_BB | RANK_8_BB)) != 0)
            return false;

        // 4. Board representation legality:
        //    - Pieces' bits must align with occupancy bitboards.
        //    - All bits corresponding to the piece must be set correctly.
        //    - Bits corresponding to other pieces and types must be empty.
        for (int square = A1_VAL; square <= H8_VAL; ++square) {
            int piece = getPiece(square);
            if (piece == NO_PIECE_VAL) {
                if ((squareToBB(square) & (occupancy() | occupancyBySide(WHITE_VAL) |
                        occupancyBySide(BLACK_VAL))) != 0)
                    return false;
            }
            for (int pieceType : PieceType.allPieceTypesValues()) {
                if (pieceType == Piece.type(piece)) { // all bits need to be set
                    if ((squareToBB(square) &
                            occupancy()                                  &
                            occupancyBySide(Piece.side(piece))            &
                            occupancyByType(pieceType)                   &
                            ~occupancyByPiece(Piece.flipped(piece))      &
                            ~occupancyBySide(Side.flipped(Piece.side(piece))) &
                            occupancyByPiece(piece)) == 0)
                        return false;
                }
                else { // all bits need to be empty
                    if ((squareToBB(square) & (
                            occupancyByPiece(Piece.valueOf(WHITE_VAL, pieceType)) |
                                    occupancyByPiece(Piece.valueOf(BLACK_VAL, pieceType)) |
                                    occupancyByType(pieceType))) != 0)
                        return false;
                }
            }
        }

        // 5. Castling validation:
        //    - Validates the legality valueOf castling moves given the castling rights.
        //    - in case valueOf normal chess make sure that the dest king and rook in the correct place.
        for (int castleRight : new int[]{WHITE_SHORT, WHITE_LONG, BLACK_SHORT, BLACK_LONG}) {
            if ((state.castlingRights & castleRight) != 0) {
                int side = castlingSide(castleRight);
                boolean isShort = isShortCastle(castleRight);
                int kSq = startSquare(castlingMoves[castleRight]);
                int rSq = destSquare(castlingMoves[castleRight]);

                if (getPiece(kSq) != Piece.valueOf(side, KING_VAL) ||
                        getPiece(rSq) != Piece.valueOf(side, ROOK_VAL) ||
                        Rank.flippedIfBlack(side, RANK_1_VAL) != squareRank(kSq) || //king in the correct rank
                        (isShort && kSq >= rSq || !isShort && kSq <= rSq) || /*i think it >=  */
                        (!isChess960 && (rSq != Square.flippedIfBlack(side, isShort? H1_VAL: A1_VAL) || kSq != Square.flippedIfBlack(side, E1_VAL) )))
                    return false;
            }
        }

        // All criteria passed; the position is legal.
        return true;
    }

    // return true
    public boolean isCastlingAvailableOnPosition(int castleRight, int kSq, int rSq){
        if (castleRight != WHITE_SHORT &&  castleRight != WHITE_LONG && castleRight != BLACK_SHORT && castleRight !=  BLACK_LONG){
            throw new IllegalArgumentException("Castle right must be on valueOf : [WHITE_SHORT, WHITE_LONG, BLACK_SHORT, BLACK_LONG");
        }
        int side = castlingSide(castleRight);
        boolean isShort = isShortCastle(castleRight);
//        if (!isChess960){
//            return (rSq == flipped(side, isShort ? H1_VAL : A1_VAL) && kSq == flipped(side, E1_VAL));
//        }
        return getPiece(kSq) == Piece.valueOf(side, KING_VAL) &&
                getPiece(rSq) == Piece.valueOf(side, ROOK_VAL) &&
                Rank.flippedIfBlack(side, RANK_1_VAL) == squareRank(kSq) && // king in the correct rank
                Rank.flippedIfBlack(side, RANK_1_VAL) == squareRank(rSq) && // rook in the correct rank
                ((!isShort || kSq < rSq) && (isShort || kSq > rSq)) &&
                // extra check on normal check to make sure that king and rook in correct placmant
                (isChess960 || (rSq == Square.flippedIfBlack(side, isShort ? H1_VAL : A1_VAL) && kSq == Square.flippedIfBlack(side, E1_VAL)));

    }

    /**
     * Retrieves the move history valueOf the game.
     *
     * @return a list valueOf Move objects representing the move history
     */
    public List<Integer> moveHistory() {
        LinkedList<Integer> result = new LinkedList<>();
        for (PositionState st = state; st != null && st.lastMove != NULL_MOVE; st = st.previous) {
            result.addFirst(st.lastMove); // O(1) in LinkedList
        }
        return result;
    }

//    private String moveHistory(){
//        PositionState st = state;
//        StringBuilder res = new StringBuilder();
//        while (st.lastMove != 0){
//            res.insert(0, moveName(st.lastMove) + " ");
//            st = st.previous;
//        }
//        return res.toString();
//    }

    /**
     * Get a string representation valueOf the current position.
     * This method generates a visual representation valueOf the chessboard along with important position information.
     *
     * @return A string containing the board layout, FEN, checkers, pin mask, key, move history, and repetition count.
     */
    public String posString() {
        StringBuilder result = new StringBuilder();

        // Generate the chessboard layout
        for (int i = 8 - 1; i >= 0; --i) {
            result.append("  +---+---+---+---+---+---+---+---+\n");
            result.append(i + 1).append(" ");

            for (int j = 0; j < 8; ++j) {
                int piece = getPiece((i * 8) + j);
                char to_print = piece != NO_PIECE_VAL ? Piece.charName(piece) : ' ';//todo to check
                result.append("| ").append(to_print).append(" ");
            }
            result.append("|\n");
        }
        result.append("  +---+---+---+---+---+---+---+---+\n");
        result.append("    a   b   c   d   e   f   g   h\n\n");

        // Append additional position information
        result.append("Fen:        ").append(getFen()).append("\n");
        result.append("Checker:    ").append(toBinaryString(state.checkers)).append("\n");
        result.append("Pin Mask:   ").append(toBinaryString(state.pinMask)).append("\n");
        result.append("key:        ").append(state.key).append("\n");
        result.append("moves play: ").append(moveHistory().stream().map(Move::stringName).toList()).append("\n");
        result.append("repetition: ").append(state.numRepetition).append("\n");
        result.append("\n");

        return result.toString();
    }


    /**
     * Split a FEN string into its individual components.
     *
     * @param fen The FEN string to be split.
     * @return An array containing the individual components valueOf the FEN string.
     */
    private static String[] splitFen(String fen) {
        return fen.trim().replaceAll("\\s+", " ").split(" ");
    }

    public boolean isChess960() {
        return isChess960;
    }


    public int getNumMoves() {
        return (numMoves / 2) + 1;
    }
}



//
//    public String convertMoveToSAN1(int move) { // assume move not already made on the boared
//
//        String result = "";
//
////        int move = state.lastMove;
//        int start = startSquare(move);
//        int dest = destSquare(move);
//        int piece = getPiece(start);
//        int side = side(piece);
//        int moveType = moveType(move);
//        int type = type(piece);
//
//        boolean isCapturing = getPiece(dest) != NO_PIECE_VAL || moveType == EN_PASSANT;
//
//        if (type == PAWN_VAL) {
//            result = isCapturing ? File.charName(squareFile(start)) + "x" : "";
//            result += stringName(dest);
//            result += moveType == PROMOTION ? "=" + charName(Piece.valueOf(side, promotePT(move))) : "";
//        }
//
//        else if (moveType == CASTLING) {
//            assert isLegalCastlingMove(move);
//            result =  start < dest ? "O-O" : "O-O-O"; // todo to check chackmate
//        }
//        else {
//            result += charName(piece);
//
//            long ambiguitySamePieces = (attackersBB(dest, occupancyBB) & occupancyByPiece(piece)) ^ squareToBB(start);
//            if (ambiguitySamePieces != 0) { // handle ambiguity case
//                if ((fileBB(squareFile(start)) & ambiguitySamePieces) == 0) // there no same piece on same file
//                    result += File.charName(squareFile(start));
//
//                else if ((rankBB(squareRank(start)) & ambiguitySamePieces) == 0) // there no same piece on same rank
//                    result += charName(squareRank(start));
//
//                else // there same piece on same file and on same rank
//                    result += stringName(start);
//
//            }
//
//            // in case valueOf capture adding 'x'.
//            result += isCapturing ? "x" : "";
//            result += stringName(dest);
//        }
//
//        makeMove(move, new PositionState());
//        if (inCheck())
//            result += new MoveList(this).size() > 0 ? "+" : "#";
//        undoMove(move);
//
//        return result;
//    }

//
//
//    public String toSanLastMove() {
//
//        String result = "";
//
//        int move = state.lastMove;
//        int start = startSquare(move);
//        int dest = destSquare(move);
//        int piece = getPiece(dest);
//        int side = side(piece);
//        int moveType = moveType(move);
//        int type = type(piece);
//
////        state.capturedPiece
//
//        boolean isCapturing = state.capturedPiece != NO_PIECE_VAL || moveType == EN_PASSANT;
//
//        if (type == PAWN_VAL) {
//            result = isCapturing ? File.charName(squareFile(start)) + "x" : "";
//            result += stringName(dest);
//            result += moveType == PROMOTION ? "=" + charName(Piece.valueOf(side, promotePT(move))) : "";
//        }
//
//        else if (moveType == CASTLING) {
////            assert isLegalCastlingMove(move);
//            result =  start < dest ? "O-O" : "O-O-O"; // todo to check chackmate
//        }
//
//        else {
//            result += charName(piece);
//            long occupancy = occupancyBB ^ (squareToBB(start) | squareToBB(dest));
//
//            long ambiguitySamePieces = (attackersBB(dest, occupancy) & occupancyByPiece(piece));
//            if (ambiguitySamePieces != 0) { // handle ambiguity case
//                if ((fileBB(squareFile(start)) & ambiguitySamePieces) == 0) // there no same piece on same file
//                    result += File.charName(squareFile(start));
//
//                else if ((rankBB(squareRank(start)) & ambiguitySamePieces) == 0) // there no same piece on same rank
//                    result += charName(squareRank(start));
//
//                else // there same piece on same file and on same rank
//                    result += stringName(start);
//
//            }
//
//            // in case valueOf capture adding 'x'.
//            result += isCapturing ? "x" : "";
//            result += stringName(dest);
//        }
//
////        makeMove(move, new PositionState());
//        if (inCheck())
//            result += new MoveList(this).size() > 0 ? "+" : "#";
////        undoMove(move);
//
//        return result;
//    }

//    public String toSanLastMove(int move) {
//        assert isPseudoLegalMove(move) && isLegalMove(move);
//        makeMove(move, new PositionState());
//        String result = toSanLastMove();
//        undoMove(move);
//        return result;
//
//
//    }

