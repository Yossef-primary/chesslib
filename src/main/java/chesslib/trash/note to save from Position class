


// ===========             Note to save             =================

//    public boolean isMoveGiveCheck(int move) { // todo test this method
//        int start = startSquare(move);
//        int dest = destSquare(move);
//        int moveType = moveType(move);
//        int movingPiece = getPiece(start);
//        int movingSide = Piece.side(movingPiece);
//        int enemySide = Side.flipped(movingSide);
//        int movingType = 0;
//
//        int oppKingSq = squareOf(enemySide, KING);
//
//        // === Simulate occupancy after the move ===
//        long newOcc = occupancyBB ^ squareToBB(start) | squareToBB(dest);
//
//        if (Move.isNormalPieceAndPawnOrPushTwice(moveType)){
//            movingType = Piece.type(movingPiece);
//        }
//        else if (moveType == CASTLING) {
//            movingType = ROOK;
//            dest = castlingDestSquareRook[dest];
//            return  ((attacks(movingType, dest, newOcc) & squareToBB(oppKingSq)) != 0);
//        }
//        // === Special handling for en passant ===
//        else if (moveType == EN_PASSANT) {
//            int capturedSq = dest - Direction.forward(movingSide);
//            newOcc ^= squareToBB(capturedSq); // Remove captured pawn
//        }
//        else { // moveType == PROMOTION{
//            movingType = promotePT(move);
//
//        }
//
//        // === Check if the moved piece attacks the enemy king ===
//        long attacks = attacks(movingType, dest, newOcc);
//
//        if ((attacks & squareToBB(oppKingSq)) != 0)
//            return true;
//
//        // === Check for discovered check (revealed check) ===
//        long between = Bitboard.pathBetween(dest, oppKingSq);
//        if ((between & squareToBB(start)) != 0) {
//            // The piece moved was on a line to the king
//            // Check if any piece from our side behind `start` now gives check
//            long revealedAttackers = attackersBB(oppKingSq, newOcc) & occupancyBySide(movingSide);
//            // & occupancyBySide(movingSide) this is not true it need to mask with the rook queen / on files / and bishops on diognal
//            return revealedAttackers != 0;
//        }
//
//        return false;
//    }



/*
    version of do meve by seaperate pawns move section
            if (type(getPiece(start)) == PAWN){
                assert (Square.distance(start, dest) == 16) == ((start ^ dest) == 16);
                state.rule50 = 0;
                if (moveType == NORMAL){
                    movePiece(start, dest);
                }

                else if ((start ^ dest) == 16) { // push twice
                    movePiece(start, dest);
                    int epSquare = start + Direction.forward(sideMoved);
//                    state.enPassant = (occupancyByType(sideToMove, PAWN) & pawnAttacks(
//                            sideMoved, epSquare)) == 0 ? NULL_SQUARE : epSquare;
//                    state.key ^= enPassantKeys[state.enPassant]; // in case of epSquare == NULL_SQUARE, it does nothing.
                    if ((occupancyByType(sideToMove, PAWN) & pawnAttacks(sideMoved, epSquare)) != 0){
                        state.enPassant = epSquare;
                        state.key ^= enPassantKeys[state.enPassant];
                    }
                }

                else if (moveType == Move.EN_PASSANT) {
                    removePiece(dest - Direction.forward(sideMoved));
                    movePiece(start, dest);
                    // todo maybe update the capturing piece
                }

                else if (moveType == Move.PROMOTION) {
                    addPiece(Piece.of(sideMoved, promotePT(move)), dest);
                    removePiece(start);
                }
            }


    public boolean isMoveGiveCheck(int move){ // todo that in need to save every positon the blockeer getBy the enemy king (not in the pin mask)
        int startSq = Move.startSquare(move);
        int destSq = Move.destSquare(move);

        int piece = getPiece(startSq);
        int side = sideToMove;

        int enemyKsq = squareOf(Side.flipped(side), KING);


        // in castling need to convert dest to rook dest
        // in promotion need to conver piece to promote piece
        // in en passant its way to far complicated


        long oppKingSqBB = Bitboard.squareToBB(enemyKsq);
        long pathToKing = pathBetween(destSq, enemyKsq);

        int moveType = Move.moveType(move);
        if (moveType != NORMAL) {
            if (moveType == PROMOTION) {
                piece = Piece.valueOf(side, promotePT(move));
            }
            else if (moveType == CASTLING){
                destSq = castlingDestSquareRook[destSq];
            }
            else if (moveType == EN_PASSANT){
                // simulate do, undo move
                int captureSq = destSq - Direction.forward(sideToMove);
                long occAfterMove = occupancyBB ^ squareToBB(startSq) ^ squareToBB(destSq) ^ squareToBB(captureSq);
                if ((rookAttacks(enemyKsq, occAfterMove) & occupancyBySideAndType(sideToMove, ROOK, QUEEN)) == 0 &&
                        (bishopAttacks(enemyKsq, occAfterMove) & occupancyBySideAndType(sideToMove, BISHOP, QUEEN)) == 0){
                    return false;
                }
            }
        }
        // base, is it direct or discover
        return
                // piece can reach to opponent king and there is no blocker.
                ((Bitboard.attacks(Piece.type(piece), destSq) & oppKingSqBB) != 0 && (pathToKing & occupancyBB) == oppKingSqBB)
                        // is discover check
                        || ((squareToBB(startSq) & state.pinMask2[Side.flipped(sideToMove)]) != 0 && !onSameLine(startSq, destSq, enemyKsq));
    }






    ===========       end save letter        ==============
 */


//   =================     todelet       ========================


//
//    public String convertMoveToSAN1(int move) { // assume move not already made on the boared
//
//        String result = "";
//
////        int move = state.lastMove;
//        int start = startSquare(move);
//        int dest = destSquare(move);
//        int piece = getPiece(start);
//        int side = side(piece);
//        int moveType = moveType(move);
//        int type = type(piece);
//
//        boolean isCapturing = getPiece(dest) != NULL_PIECE || moveType == EN_PASSANT;
//
//        if (type == PAWN) {
//            result = isCapturing ? File.getName(Square.file(start)) + "x" : "";
//            result += getName(dest);
//            result += moveType == PROMOTION ? "=" + getName(Piece.getBy(side, promotePT(move))) : "";
//        }
//
//        else if (moveType == CASTLING) {
//            assert isLegalCastlingMove(move);
//            result =  start < dest ? "O-O" : "O-O-O"; // todo to check chackmate
//        }
//        else {
//            result += getName(piece);
//
//            long ambiguitySamePieces = (attackersBB(dest, occupancyBB) & occupancyByPiece(piece)) ^ squareToBB(start);
//            if (ambiguitySamePieces != 0) { // handle ambiguity case
//                if ((fileBB(Square.file(start)) & ambiguitySamePieces) == 0) // there no same piece on same file
//                    result += File.getName(Square.file(start));
//
//                else if ((rankBB(Square.rank(start)) & ambiguitySamePieces) == 0) // there no same piece on same rank
//                    result += getName(Square.rank(start));
//
//                else // there same piece on same file and on same rank
//                    result += getName(start);
//
//            }
//
//            // in case getBy capture adding 'x'.
//            result += isCapturing ? "x" : "";
//            result += getName(dest);
//        }
//
//        makeMove(move, new PositionState());
//        if (inCheck())
//            result += new MoveList(this).size() > 0 ? "+" : "#";
//        undoMove(move);
//
//        return result;
//    }

//
//
//    public String toSanLastMove() {
//
//        String result = "";
//
//        int move = state.lastMove;
//        int start = startSquare(move);
//        int dest = destSquare(move);
//        int piece = getPiece(dest);
//        int side = side(piece);
//        int moveType = moveType(move);
//        int type = type(piece);
//
////        state.capturedPiece
//
//        boolean isCapturing = state.capturedPiece != NULL_PIECE || moveType == EN_PASSANT;
//
//        if (type == PAWN) {
//            result = isCapturing ? File.getName(Square.file(start)) + "x" : "";
//            result += getName(dest);
//            result += moveType == PROMOTION ? "=" + getName(Piece.getBy(side, promotePT(move))) : "";
//        }
//
//        else if (moveType == CASTLING) {
////            assert isLegalCastlingMove(move);
//            result =  start < dest ? "O-O" : "O-O-O"; // todo to check chackmate
//        }
//
//        else {
//            result += getName(piece);
//            long occupancy = occupancyBB ^ (squareToBB(start) | squareToBB(dest));
//
//            long ambiguitySamePieces = (attackersBB(dest, occupancy) & occupancyByPiece(piece));
//            if (ambiguitySamePieces != 0) { // handle ambiguity case
//                if ((fileBB(Square.file(start)) & ambiguitySamePieces) == 0) // there no same piece on same file
//                    result += File.getName(Square.file(start));
//
//                else if ((rankBB(Square.rank(start)) & ambiguitySamePieces) == 0) // there no same piece on same rank
//                    result += getName(Square.rank(start));
//
//                else // there same piece on same file and on same rank
//                    result += getName(start);
//
//            }
//
//            // in case of capture adding 'x'.
//            result += isCapturing ? "x" : "";
//            result += getName(dest);
//        }
//
////        makeMove(move, new PositionState());
//        if (inCheck())
//            result += new MoveList(this).size() > 0 ? "+" : "#";
////        undoMove(move);
//
//        return result;
//    }

//    public String toSanLastMove(int move) {
//        assert isPseudoLegalMove(move) && isLegalMove(move);
//        makeMove(move, new PositionState());
//        String result = toSanLastMove();
//        undoMove(move);
//        return result;
//
//
//    }


//    private String moveHistory(){
//        PositionState st = state;
//        StringBuilder res = new StringBuilder();
//        while (st.lastMove != 0){
//            res.insert(0, getName(st.lastMove) + " ");
//            st = st.previous;
//        }
//        return res.toString();
//    }


//    public boolean isCastlingAvailableOnPosition(int castleRight, int kSq, int rSq){
//        if (!Castling.isSingleCastlingRights(castleRight)){
//            throw new IllegalArgumentException("Castle right must be from : [WHITE_SHORT, WHITE_LONG, BLACK_SHORT, BLACK_LONG");
//        }
//        int side = castlingSide(castleRight);
//        boolean isShort = isShortCastle(castleRight);
////        if (!isChess960){
////            return (rSq == flipped(side, isShort ? H1 : A1) && kSq == flipped(side, E1));
////        }
//        return getPiece(kSq) == Piece.valueOf(side, KING) &&
//                getPiece(rSq) == Piece.valueOf(side, ROOK) &&
//                Rank.flippedIfBlack(side, RANK_1) == Square.rank(kSq) && // king in the correct rank
//                Rank.flippedIfBlack(side, RANK_1) == Square.rank(rSq) && // rook in the correct rank
////                ((!isShort || kSq < rSq) && (isShort || kSq > rSq)) &&
//                (isShort == (kSq < rSq)) &&
//                // extra check on normal check to make sure that king and rook in correct placmant
//                (isChess960 || (rSq == Square.flippedIfBlack(side, isShort ? H1 : A1) && kSq == Square.flippedIfBlack(side, E1)));
//
//    }


/**
 * //     * Asserts that the current position is legal, checking various conditions.
 * //     * Used for debugging and testing purposes.
 * //
 */
//    private void assertPositionIsLegal() {
//        // Only one king for each side.
//        assert hasOneBit(occupancyByPiece(WHITE_KING)) && hasOneBit(occupancyByPiece(BLACK_KING)) :
//                "Invalid number valueOf kings";
//
//        // Opponent side to move not in check.
//        assert attackersBB(sideToMove, squareOf(Side.flipped(sideToMove), KING), occupancy()) == 0 :
//                "King not in the side to move is under attack\n" + posString();
//
//        // Pawn cannot be on the first or last rank.
//        assert (occupancyByType(PAWN) & (RANK_1_BB | RANK_8_BB)) == 0 :
//                "Pawn on first or last rank";
//
//        // En passant validation was done by setFen method.
//
//        // Check if the board representation is legal.
//        for (int square = A1; square <= H8; ++square) {
//            int piece = getPiece(square);
//            assert piece != NULL_PIECE || (squareToBB(square) & (occupancy() |
//                    occupancyBySide(WHITE) | occupancyBySide(BLACK))) == 0 :
//                    String.format("Piece on square %s, piece is %c - bitboards not synchronized.\n" + posString(),
//                            Square.getName(square), Piece.getName(piece));
//            for (int pieceType : PieceType.intValues()) {
//                if (pieceType == Piece.type(piece)) { // All bits need to be set.
//                    assert (squareToBB(square) &
//                            occupancy() &
//                            occupancyBySide(Piece.side(piece)) &
//                            occupancyByType(pieceType) &
//                            ~occupancyByPiece(Piece.flipped(piece)) &
//                            ~occupancyBySide(Side.flipped(Piece.side(piece))) &
//                            occupancyByPiece(piece)) != 0 :
//                            String.format("Piece on square %s, piece is %c - bitboards not synchronized.\n" + posString(),
//                                    Square.getName(square), Piece.getName(piece));
//                } else { // All bits need to be empty.
//                    assert (squareToBB(square) & (
//                            occupancyByPiece(Piece.valueOf(WHITE, pieceType)) |
//                                    occupancyByPiece(Piece.valueOf(BLACK, pieceType)) |
//                                    occupancyByType(pieceType))) == 0 :
//                            String.format("Piece on square %s, piece is %c - bitboards not synchronized.\n" + posString(),
//                                    Square.getName(square), Piece.getName(piece));
//                }
//            }
//        }
//
//        // Castling validation, check if all the castling rights given by the user are valid on the board.
//        // in case of normal chess make sure that the dest king and rook in the correct place.
//        for (int castleRight : new int[]{WHITE_SHORT, WHITE_LONG, BLACK_SHORT, BLACK_LONG}) {
//            if (canCastle(castleRight)) {
//                int side = castlingSide(castleRight);
//                boolean isShort = (isShortCastle(castleRight));
//                int kSq = startSquare(castlingMoves[castleRight]);
//                int rSq = destSquare(castlingMoves[castleRight]);
//                assert getPiece(rSq) == Piece.valueOf(side, ROOK) &&
//                        Rank.flippedIfBlack(side, RANK_1) == Square.rank(kSq) && // King in the correct rank.
//                        (isShort && kSq < rSq || !isShort && kSq > rSq) &&
//                        (isChess960 || (rSq == Square.flippedIfBlack(side, isShort? H1: A1) && kSq == Square.flippedIfBlack(side, E1))):
//                        "Castling rights invalid";
//            }
//        }
//    }
    /*
    //        NOT DELET WROGN PERFORMANCE TEST AT POSITION
    a5a4: 239316146
a5a6: 270853688
e2e3: 193659561
g2g3: 76018380
e2e4: 147506250
g2g4: 229481895
b4b1: 334238252
b4b2: 220015036
b4b3: 255018754
b4a4: 203218268
b4c4: 289573614
b4d4: 265831872
b4e4: 232703176
b4f4: 50516708
Nodes count: 3007951600
Time: 49.671382125



    /**
     * Checks if a chess move is pseudo-legal based on the following conditions:
     * <ol>
     *   <li>Verify if the side to move corresponds to the side of the moving piece.</li>
     *   <li>Ensure that the piece can move according to the occupancy on the board.</li>
     *   <li>Check if the move corresponds to the allowed directions for the piece.</li>
     *   <li>Verify if the move type is valid for the given piece.</li>
     *   <li>Check if the move cancels a check on the position (not checking if the moved piece is on pin).</li>
     * </ol>
     *
     * @param move The encoded representation of the move to be checked.
     * @return {@code true} if the move is pseudo-legal, {@code false} otherwise.
     */
//public boolean isPseudoLegalMove1(int move) {
//    // Step 0: Extract relevant information from the move
//    int start = startSquare(move);
//    int dest = destSquare(move);
//    int piece = getPiece(start);
//    int pieceSide = Piece.side(piece);
//    int moveType = moveType(move);
//    int pt = Piece.type(piece);
//    int promotePt = promotePT(move);
//
//    // Step 1 : Check piece is exist on move start and check if the side to move corresponds to the piece side.
//    // and check the promotion piece type set correctly
//    if (piece == NULL_PIECE ||
//            pieceSide != sideToMove ||
//            moveType != PROMOTION && promotePt != NULL_PIECE_TYPE||
//            (moveType == PROMOTION && (promotePt == NULL_PIECE_TYPE || promotePt == PAWN || promotePt == KING)))
//        return false;
//
//
//
//    // Step 2, 3: Check if the piece can move according to the occupancy on the board
////        long enemy = occupancyBySide(flipped(sideToMove));
////        long empty = ~occupancyBB;
////        long target = pt != PAWN ? enemy | empty :
////                Square.file(start) == Square.file(dest) ? empty : enemy;
//    if (moveType == NORMAL  || moveType == PAWN_PUSH_TWICE || moveType == PROMOTION || moveType == NORMAL_PAWN_MOVE) {
//        if ((attacksAndMoves(sideToMove, pt, start, occupancy(), occupancyBySide(Side.flipped(pieceSide))) & squareToBB(dest)) == 0)
//            return false;
//    }
//
//    // Step 4: Check if the move corresponds to the direction that the piece can walk
//    else if (moveType == CASTLING) {
//
//        int castleRight = start < dest ? shortCastling(sideToMove) : longCastling(sideToMove);
//        if (/*state.checkers != 0 ||*/
//                ((castleRight & state.castlingRights) == 0) ||
//                        castlingMoves[castleRight] != move) // This validates that start contains king and dest contains rook.
//            return false;
//    }
//
//    // Step 4: Check validation of en passant move.
//    else if (moveType == EN_PASSANT) {
//        // check if you can reach dest square from start by doing en passant walk, and addition check if the destination square are empty
//        if (pt != PAWN || dest != state.enPassant ||
//                (pawnAttacks(sideToMove, start) & squareToBB(dest) & ~occupancyBB) == 0)
//            return false;
//        // in check, we need to end the function here because the check down not cover all the
//        // cases of en passant move leave own king in check.
////            if (inCheck())
////                return isLegalEnPassantMove(move);
//    }
//
//    // Step 5: Check if the position is in check and if the piece move cancels this check
//    // (not checking if the piece moved is on pin)
////        if (state.checkers != 0) {
////            long checkMask = pathBetween(state.kingSquare, lsbToSquare(state.checkers));
////            return type(piece) == KING ?
////                    attackersBB(flipped(sideToMove), dest, occupancyBB ^ squareToBB(state.kingSquare)) == 0 :
////                    hasOneBit(state.checkers) && (checkMask & squareToBB(dest)) != 0;
////        }
//
//    return true; // If all checks pass, the move is considered pseudo-legal
//}


//    public boolean isLegalMove2(int move) {
//        int start = startSquare(move);
//        int dest = destSquare(move);
//        int moveType = moveType(move);
//        int pieceMoved = getPiece(start);
//        int ksq = state.kingSquare;
//        int enemySide = Side.flipped(sideToMove);
//
//        if (moveType == NORMAL || moveType == PAWN_PUSH_TWICE || moveType == PROMOTION || moveType == NORMAL_PAWN_MOVE) {
//            // In case getofe king move, check if the destination square is safe.
//            return (Piece.type(pieceMoved) == KING) ?
//                    attackersBB(enemySide, dest, occupancyBB ^ squareToBB(ksq)) == 0 :
//                    ((squareToBB(start) & state.pinMask) == 0) || onSameLine(start, dest, ksq); // check if this piece is pined and in case getof along pin line.
//        }
//
//        // Here, move type must be either EN_PASSANT or CASTLING.
//        return moveType == CASTLING ? isLegalCastlingMove(move) : isLegalEnPassantMove(move);
//    }


//    public boolean isFullyLegalMove(int start, int dest, int promoteType) {
//        return isFullyLegalMove(toMove(start, dest, promoteType));
//    }

// uci move represents castling in not cess960 as king startSq to king destSq.
// so in that case we need to change the king dest square.
//    public String toUciMove(int move){
//        if (Move.moveType(move) == CASTLING && !isChess960()){
//            int startSq = startSquare(move);
//            int destSq = destSquare(move);
//            // modify the dest square
//            destSq = Square.valueBy(startSq < destSq ? FILE_G : FILE_C, Square.rank(startSq));
//            move = Move.create(startSq, destSq, CASTLING);
//        }
//        return Move.getName(move);
//    }
//
////    public int fromUciMove(int sqStart, int sqDest , int promotePT){
////        return toMove(sqStart, sqDest, promotePT);
////    }
//
//
//    public int fromUciMove(String uciMove){
//        int move = Move.create(uciMove);
//        return toMove(startSquare(move), destSquare(move), promotePT(move));
//    }


//int setCastlingRights(String castlingFen){
//    int castlingRights = 0;
//    Arrays.fill(castlingOptionsMask, ALL_CASTLING);
//    int wKing = squareOf(WHITE, KING);
//    int bKing = squareOf(BLACK, KING);
//
//    castlingOptionsMask[wKing] = ALL_CASTLING - (WHITE_SHORT | WHITE_LONG);
//    castlingOptionsMask[bKing] = ALL_CASTLING - (BLACK_SHORT | BLACK_LONG);
//
//    int[] kingsSquares = {wKing, bKing};
//
//    for (char c : castlingFen.toCharArray()) {
//        int side = Character.isUpperCase(c) ? WHITE : BLACK;
//        c = Character.toLowerCase(c);
//        int rookSq, kingSq = kingsSquares[side];
//
//        // find the rookSq square, that made the castle.
//        if (c == 'k') {
//            rookSq = Square.flippedIfBlack(side, H1);
//            while (getPiece(rookSq) != Piece.valueBy(side, ROOK) && rookSq > A1) rookSq--;
//
//        }
//        else if (c == 'q'){
//            rookSq = Square.flippedIfBlack(side, A1);
//            while (getPiece(rookSq) != Piece.valueBy(side, ROOK) && rookSq < H1) rookSq++;
//        }
//
//        else if (c >= 'a' && c <= 'h')
//            rookSq = Square.valueBy(File.getBy(c), Rank.flippedIfBlack(side, Rank.RANK_1));
//        else break; // c = "-"
//
//        if (getPiece(rookSq) == Piece.valueBy(side, ROOK) && getPiece(kingSq) == Piece.valueBy(side, KING)) {
//            int castleRight = rookSq > kingSq ? shortCastling(side) : longCastling(side);
//            int destKing = isShortCastle(castleRight) ? Square.flippedIfBlack(side, G1) : Square.flippedIfBlack(side, C1);
//            int destRook = isShortCastle(castleRight) ? Square.flippedIfBlack(side, F1) : Square.flippedIfBlack(side, D1);
//            //update castle right info
//            castlingRights += castleRight;
//            castlingOptionsMask[rookSq] = ALL_CASTLING - castleRight;
//            castlingDestSquareKing[rookSq] = destKing;
//            castlingDestSquareRook[rookSq] = destRook;
//            castlingKingPath[rookSq] = pathBetween(kingSq, destKing) & ~squareToBB(kingSq);
//            castlingPath[rookSq] = castlingKingPath[rookSq] | pathBetween(rookSq, destRook) & ~squareToBB(rookSq);
//            castlingMoves[castleRight] = Move.create(kingSq, rookSq, CASTLING);
//        }
//    }
//    state.castlingRights = castlingRights;
//    return castlingRights;
//
//}

//    public void setFen(String fen, PositionState state){
//        this.state = state;
//        int[] copy_Board = new int[Square.VALUES_COUNT];
//        int[] pii = new int[12];
//
//        System.arraycopy(board, 0, copy_Board, 0, board.length);
//    }

//
//    public boolean inInsufficientMaterial2() {
//        int countPiece = Bitboard.bitCount(occupancyBB);
//
//        return (countPiece <= 4 && // KBN VS K todo to fix
//                occupancyByType(QUEEN, ROOK, PAWN) == 0) &&
//                Bitboard.isOnSameColor(occupancyByType(BISHOP)); // it there is 1 or 0 bishop on the board it return true
//    }
//


//     */